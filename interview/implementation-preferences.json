{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "version": "1.0.0",
  "description": "Implementation preferences interview for /acis:implement-parallel. Two-part interview: WHAT to build (scope, priorities, MVP boundaries, feature flags) and HOW to build (coding style, error handling, observability, design principles, build configuration).",
  "interviewPrinciples": {
    "defaultFirst": "Every question has a sensible default marked (Recommended). Users can accept defaults rapidly or customize.",
    "autoDetect": "Before asking, attempt to detect preferences from existing codebase files (tsconfig.json, .eslintrc, package.json, existing source). Pre-fill defaults from detection.",
    "skipIfKnown": "If .acis-config.json already contains implementationPreferences, load them and ask only: 'Use saved preferences? [Yes / Modify / Start fresh]'"
  },
  "autoDetection": {
    "description": "Run these checks BEFORE the interview to pre-fill defaults. All commands are Bash 3.2 compatible.",
    "checks": [
      {
        "field": "platform.language",
        "command": "[ -f tsconfig.json ] && echo 'typescript' || ([ -f jsconfig.json ] && echo 'javascript' || echo 'unknown')",
        "fallback": "typescript"
      },
      {
        "field": "platform.packageManager",
        "command": "[ -f pnpm-lock.yaml ] && echo 'pnpm' || ([ -f yarn.lock ] && echo 'yarn' || ([ -f package-lock.json ] && echo 'npm' || echo 'unknown'))",
        "fallback": "npm"
      },
      {
        "field": "platform.testFramework",
        "command": "grep -l 'vitest\\|jest\\|mocha' package.json 2>/dev/null | head -1 && (grep -q 'vitest' package.json && echo 'vitest' || (grep -q 'jest' package.json && echo 'jest' || echo 'unknown'))",
        "fallback": "vitest"
      },
      {
        "field": "codingStyle.semicolons",
        "command": "[ -f .eslintrc.json ] && grep -q 'semi.*always' .eslintrc.json 2>/dev/null && echo 'always' || echo 'detect'",
        "fallback": "as-needed"
      },
      {
        "field": "codingStyle.quoteStyle",
        "command": "[ -f .prettierrc ] && grep -q 'singleQuote.*true' .prettierrc 2>/dev/null && echo 'single' || echo 'detect'",
        "fallback": "single"
      },
      {
        "field": "platform.monorepo",
        "command": "[ -f pnpm-workspace.yaml ] || [ -f lerna.json ] || grep -q 'workspaces' package.json 2>/dev/null && echo 'true' || echo 'false'",
        "fallback": "false"
      }
    ]
  },
  "phases": [
    {
      "id": 1,
      "name": "What to Build — Scope & Priorities",
      "description": "Define WHAT gets built: which subsystems, MVP scope, prioritization, and feature boundaries",
      "targetDuration": "2-3 minutes",
      "questions": [
        {
          "id": "IP-W1",
          "question": "GENESIS extracted multiple subsystems. Which ones are essential for the first working version (MVP)?",
          "header": "MVP scope",
          "type": "multi",
          "required": true,
          "topics": ["scope"],
          "default": "all-subsystems",
          "dynamicOptions": true,
          "dynamicSource": "Populated from GENESIS SUBSYSTEMS_DRAFT.md — each extracted subsystem becomes an option",
          "options": [
            {
              "label": "All subsystems (Recommended)",
              "value": "all-subsystems",
              "description": "Implement everything GENESIS specified. Best when the architecture is minimal and all parts are needed.",
              "pros": ["Complete system from day one", "No integration gaps", "Architecture coherent"],
              "cons": ["Longer to complete", "All-or-nothing risk", "May include non-essential parts"]
            },
            {
              "label": "Core subsystems only",
              "value": "core-only",
              "description": "Build only subsystems on the critical path. Defer supporting/nice-to-have subsystems.",
              "pros": ["Faster to first working version", "Focus on value", "Can validate architecture early"],
              "cons": ["Missing subsystems need stubs/mocks", "Deferred work accumulates", "Integration risk later"]
            },
            {
              "label": "Let me pick specific ones",
              "value": "manual-select",
              "description": "I'll select exactly which subsystems to include in this batch.",
              "pros": ["Full control", "Can match team capacity", "Deliberate scoping"],
              "cons": ["May miss dependencies", "Requires understanding of dependency graph"]
            }
          ],
          "followUps": [
            "Which subsystems are must-have vs nice-to-have?",
            "Are there subsystems that should be stubbed out (interface only, no implementation)?"
          ]
        },
        {
          "id": "IP-W2",
          "question": "How should subsystems be prioritized for implementation order?",
          "header": "Priority",
          "type": "single",
          "required": true,
          "topics": ["scope"],
          "default": "dependency-order",
          "options": [
            {
              "label": "Dependency order (Recommended)",
              "value": "dependency-order",
              "description": "Build foundation subsystems first, then dependents. Topological sort from GENESIS dependency graph.",
              "pros": ["No stubs needed", "Each subsystem can use real dependencies", "Natural build order"],
              "cons": ["May delay high-value subsystems", "Foundation work may feel slow initially"]
            },
            {
              "label": "Value-first (highest business value first)",
              "value": "value-first",
              "description": "Build the most impactful subsystems first, even if they need stubs for missing dependencies.",
              "pros": ["Early value delivery", "Stakeholder confidence", "Validate core hypothesis"],
              "cons": ["Stub/mock overhead", "Integration risk", "May need rework when deps are real"]
            },
            {
              "label": "Risk-first (hardest/riskiest first)",
              "value": "risk-first",
              "description": "Tackle the most technically risky or uncertain subsystems first to fail fast.",
              "pros": ["Early risk resolution", "Architecture validated", "Hard problems solved fresh"],
              "cons": ["Slower visible progress", "May demoralize team", "Easy wins deferred"]
            },
            {
              "label": "Inside-out (data layer → business logic → UI)",
              "value": "inside-out",
              "description": "Build from the data layer outward: storage → services → API → UI.",
              "pros": ["Solid foundation", "Each layer tested before next", "Natural data flow"],
              "cons": ["UI/UX feedback delayed", "Long time before anything visible"]
            }
          ],
          "followUps": [
            "Are there any subsystems that MUST be implemented before a specific deadline or milestone?"
          ]
        },
        {
          "id": "IP-W3",
          "question": "Should subsystems that aren't being implemented now get stub/interface files?",
          "header": "Stubs",
          "type": "single",
          "required": true,
          "topics": ["scope"],
          "default": "interface-stubs",
          "options": [
            {
              "label": "Interface stubs (Recommended)",
              "value": "interface-stubs",
              "description": "Create type definitions and interface files for deferred subsystems. No implementation, but the API contract exists.",
              "pros": ["Dependent subsystems can code against interfaces", "Clear API contract", "Easy to implement later"],
              "cons": ["Stubs may drift from reality", "Maintenance overhead for unused code"]
            },
            {
              "label": "Mock implementations",
              "value": "mock-implementations",
              "description": "Create mock/fake implementations that return static data. Enough to test dependent subsystems end-to-end.",
              "pros": ["Full end-to-end testing possible", "Realistic integration testing", "Good developer experience"],
              "cons": ["More code to write now", "Mocks can hide real issues", "Need maintenance"]
            },
            {
              "label": "No stubs (skip deferred)",
              "value": "no-stubs",
              "description": "Don't create anything for deferred subsystems. Dependent code will need to handle missing dependencies at build time.",
              "pros": ["No wasted effort", "No false confidence", "Clean codebase"],
              "cons": ["Dependent subsystems can't compile/test", "Integration harder later"]
            }
          ]
        },
        {
          "id": "IP-W4",
          "question": "Should the implementation include feature flags for incomplete or experimental subsystems?",
          "header": "Feature flags",
          "type": "single",
          "required": false,
          "topics": ["scope"],
          "default": "environment-flags",
          "options": [
            {
              "label": "Environment variable flags (Recommended)",
              "value": "environment-flags",
              "description": "Simple ENABLE_SUBSYSTEM_X=true env vars. Each subsystem checks its flag at startup.",
              "pros": ["Simple to implement", "No external dependencies", "Works in any environment", "Easy to toggle"],
              "cons": ["No gradual rollout", "Restart required to change", "No user-level targeting"]
            },
            {
              "label": "Configuration file flags",
              "value": "config-flags",
              "description": "Feature flags in a JSON/YAML config file. Hot-reloadable without restart.",
              "pros": ["Hot-reloadable", "Version controlled", "Groupable", "No restart needed"],
              "cons": ["Config file management", "Need file watcher", "Slightly more complex"]
            },
            {
              "label": "No feature flags",
              "value": "no-flags",
              "description": "All implemented subsystems are always active. No toggles.",
              "pros": ["Simplest code", "No dead code paths", "Clear state"],
              "cons": ["All-or-nothing deploys", "Can't disable broken subsystem without redeploy"]
            },
            {
              "label": "Feature flag service (LaunchDarkly, etc.)",
              "value": "flag-service",
              "description": "External feature flag service for runtime toggling, gradual rollout, and A/B testing.",
              "pros": ["Gradual rollout", "User targeting", "A/B testing", "Runtime control"],
              "cons": ["External dependency", "Cost", "Complexity", "Network dependency"]
            }
          ]
        },
        {
          "id": "IP-W5",
          "question": "What deliverable format should each subsystem produce?",
          "header": "Deliverables",
          "type": "multi",
          "required": true,
          "topics": ["scope"],
          "default": "code-tests-types",
          "options": [
            {
              "label": "Code + Tests + Types (Recommended)",
              "value": "code-tests-types",
              "description": "Implementation code, test files, and TypeScript type definitions. The essential trio.",
              "pros": ["Everything needed to ship", "Types document the API", "Tests verify correctness"],
              "cons": ["More to generate per subsystem"]
            },
            {
              "label": "Include API documentation",
              "value": "include-api-docs",
              "description": "Also generate JSDoc/TSDoc comments and a README per subsystem.",
              "pros": ["Self-documenting", "Easier onboarding", "API reference available immediately"],
              "cons": ["More content to maintain", "Docs can drift"]
            },
            {
              "label": "Include OpenAPI/schema definitions",
              "value": "include-schemas",
              "description": "Also generate OpenAPI specs or JSON schemas for subsystem APIs.",
              "pros": ["Machine-readable API contract", "Can generate client SDKs", "API-first design"],
              "cons": ["Additional files", "Schema maintenance", "May be premature"]
            },
            {
              "label": "Include example/seed data",
              "value": "include-seed-data",
              "description": "Also generate fixture/seed data files for development and testing.",
              "pros": ["Immediate dev experience", "Consistent test data", "Demo-ready"],
              "cons": ["Synthetic data may mislead", "Maintenance burden"]
            }
          ]
        }
      ]
    },
    {
      "id": 2,
      "name": "How to Build — Coding Style & Conventions",
      "description": "How code should look and be organized",
      "targetDuration": "1-2 minutes",
      "questions": [
        {
          "id": "IP-Q1",
          "question": "What naming convention should we follow for files and directories?",
          "header": "File naming",
          "type": "single",
          "required": true,
          "topics": ["codingStyle"],
          "default": "kebab-case",
          "options": [
            {
              "label": "kebab-case (Recommended)",
              "value": "kebab-case",
              "description": "auth-service.ts, user-repository.ts — Most common in Node/TS ecosystems. Works across all OS file systems.",
              "pros": ["Universal OS compatibility", "Matches npm package naming", "Most common in modern JS/TS"],
              "cons": ["Longer to type than camelCase"]
            },
            {
              "label": "camelCase",
              "value": "camelCase",
              "description": "authService.ts, userRepository.ts — Matches JavaScript variable naming conventions.",
              "pros": ["Matches JS variable names", "No separator characters"],
              "cons": ["Case-sensitive file systems can cause issues", "Less readable for long names"]
            },
            {
              "label": "PascalCase",
              "value": "PascalCase",
              "description": "AuthService.ts, UserRepository.ts — Common in React component files and C#-style projects.",
              "pros": ["Clear class/component association", "Standard for React components"],
              "cons": ["Case-sensitive issues on macOS/Windows", "Mixes with type names"]
            },
            {
              "label": "snake_case",
              "value": "snake_case",
              "description": "auth_service.ts, user_repository.ts — Common in Python, Ruby, Rust ecosystems.",
              "pros": ["Very readable", "Standard in many non-JS ecosystems"],
              "cons": ["Non-standard for JS/TS", "Feels foreign in Node projects"]
            }
          ],
          "followUps": [
            "Should React/UI components use a different convention (e.g., PascalCase for components)?"
          ]
        },
        {
          "id": "IP-Q2",
          "question": "What code organization pattern should subsystems follow internally?",
          "header": "Code org",
          "type": "single",
          "required": true,
          "topics": ["codingStyle"],
          "default": "feature-based",
          "options": [
            {
              "label": "Feature-based / Vertical slices (Recommended)",
              "value": "feature-based",
              "description": "Group by feature: auth/ has its own types, services, tests, routes. Each subsystem is self-contained.",
              "pros": ["High cohesion", "Easy to navigate per-feature", "Scales well", "Easy to extract to packages"],
              "cons": ["Shared utilities need a home", "Can lead to duplication if not careful"]
            },
            {
              "label": "Layer-based / Horizontal",
              "value": "layer-based",
              "description": "Group by type: types/, services/, controllers/, tests/. Traditional MVC-style separation.",
              "pros": ["Clear separation of concerns", "Easy to enforce architecture rules", "Familiar pattern"],
              "cons": ["Related code scattered across folders", "Harder to see feature boundaries"]
            },
            {
              "label": "Hybrid (Feature + shared layers)",
              "value": "hybrid",
              "description": "Features are vertical slices, but shared concerns (db, config, middleware) live in a common/ or shared/ layer.",
              "pros": ["Best of both", "Clear shared vs feature-specific boundary"],
              "cons": ["More rules to follow", "shared/ can become a dumping ground"]
            }
          ],
          "followUps": [
            "Should each subsystem have a barrel file (index.ts) exporting its public API?"
          ]
        },
        {
          "id": "IP-Q3",
          "question": "What import style should we use?",
          "header": "Imports",
          "type": "single",
          "required": false,
          "topics": ["codingStyle"],
          "default": "path-aliases",
          "options": [
            {
              "label": "Path aliases (@/subsystem) (Recommended)",
              "value": "path-aliases",
              "description": "import { Auth } from '@/auth-service' — Clean, refactor-safe imports via tsconfig paths.",
              "pros": ["Clean imports", "Refactor-safe", "No '../../../' chains"],
              "cons": ["Requires tsconfig paths setup", "Some tools need extra config"]
            },
            {
              "label": "Relative paths",
              "value": "relative",
              "description": "import { Auth } from '../../auth-service' — No configuration needed, works everywhere.",
              "pros": ["Zero config", "Works with any tool", "Explicit dependency chain"],
              "cons": ["Deep nesting gets ugly", "Fragile during refactors"]
            },
            {
              "label": "Package imports (monorepo)",
              "value": "package-imports",
              "description": "import { Auth } from '@myapp/auth-service' — Each subsystem is a workspace package.",
              "pros": ["True module boundaries", "Independent versioning possible", "Enforced API surface"],
              "cons": ["More build config", "Heavier setup", "Requires workspace tooling"]
            }
          ]
        },
        {
          "id": "IP-Q4",
          "question": "What export style should subsystem public APIs use?",
          "header": "Exports",
          "type": "single",
          "required": false,
          "topics": ["codingStyle"],
          "default": "named-exports",
          "options": [
            {
              "label": "Named exports only (Recommended)",
              "value": "named-exports",
              "description": "export function createUser() {} — Tree-shakeable, explicit, autocomplete-friendly.",
              "pros": ["Tree-shakeable", "Better autocomplete", "Explicit API surface", "Avoids naming conflicts"],
              "cons": ["More verbose imports"]
            },
            {
              "label": "Default + named exports",
              "value": "mixed-exports",
              "description": "export default class AuthService {} + named helpers — Default for main class, named for utilities.",
              "pros": ["Clear primary export", "Flexible usage"],
              "cons": ["Inconsistent naming on import side", "Not tree-shakeable for default"]
            },
            {
              "label": "Barrel re-exports",
              "value": "barrel-exports",
              "description": "index.ts re-exports from internal modules — One import path per subsystem.",
              "pros": ["Clean consumer API", "Internal structure hidden"],
              "cons": ["Can cause circular dependencies", "Larger bundle if not tree-shaken"]
            }
          ]
        }
      ]
    },
    {
      "id": 3,
      "name": "How to Build — Error Handling & Logging",
      "description": "How errors are caught, reported, and traced",
      "targetDuration": "1-2 minutes",
      "questions": [
        {
          "id": "IP-Q5",
          "question": "What error handling strategy should subsystems use?",
          "header": "Errors",
          "type": "single",
          "required": true,
          "topics": ["errorHandling"],
          "default": "typed-errors",
          "options": [
            {
              "label": "Typed error classes (Recommended)",
              "value": "typed-errors",
              "description": "Custom error classes per domain: AuthError, ValidationError, NotFoundError. Each with error code, HTTP status, and safe message.",
              "pros": ["Type-safe error handling", "Structured error responses", "Easy to map to HTTP/gRPC codes", "Instanceof checks work"],
              "cons": ["More boilerplate upfront", "Error class hierarchy can grow"]
            },
            {
              "label": "Result type (Either/Result pattern)",
              "value": "result-type",
              "description": "Functions return Result<T, E> instead of throwing. Forces callers to handle errors explicitly.",
              "pros": ["No hidden control flow", "Compiler-enforced error handling", "Functional style", "Composable"],
              "cons": ["Unusual in JS/TS ecosystem", "Verbose for simple cases", "Doesn't work with async/await natively"]
            },
            {
              "label": "Standard Error + error codes",
              "value": "error-codes",
              "description": "Throw standard Error with a code property: throw Object.assign(new Error('msg'), { code: 'AUTH_FAILED' })",
              "pros": ["Simple", "No custom classes needed", "Works with any error handler"],
              "cons": ["No type safety on error shapes", "Easy to forget error codes", "No hierarchy"]
            },
            {
              "label": "Mixed (throw at boundaries, Result internally)",
              "value": "mixed",
              "description": "Use Result<T,E> within subsystem logic, throw typed errors at API/handler boundaries.",
              "pros": ["Best of both worlds", "Clean internal logic", "Standard boundary behavior"],
              "cons": ["Two patterns to learn", "Conversion layer needed"]
            }
          ],
          "followUps": [
            "Should there be a global error handler that catches unhandled errors?"
          ]
        },
        {
          "id": "IP-Q6",
          "question": "What logging approach should subsystems use?",
          "header": "Logging",
          "type": "single",
          "required": true,
          "topics": ["logging"],
          "default": "structured-logger",
          "options": [
            {
              "label": "Structured logger (pino/winston) (Recommended)",
              "value": "structured-logger",
              "description": "JSON-structured logs with levels, context, and correlation IDs. logger.info({ userId, action }, 'User logged in')",
              "pros": ["Machine-parseable", "Searchable in log aggregators", "Correlation ID support", "Level filtering"],
              "cons": ["Hard to read in terminal without pretty-printing", "Requires logger dependency"]
            },
            {
              "label": "Console wrapper with levels",
              "value": "console-levels",
              "description": "Thin wrapper around console.log/warn/error with log levels and optional formatting.",
              "pros": ["Zero dependencies", "Easy to understand", "Works everywhere"],
              "cons": ["Not structured", "Hard to filter in production", "No correlation IDs"]
            },
            {
              "label": "Debug-style (debug package)",
              "value": "debug-namespaced",
              "description": "Namespace-based debug logging: DEBUG=app:auth,app:sync. Only outputs when namespace is enabled.",
              "pros": ["Zero cost when disabled", "Granular namespace control", "Great for development"],
              "cons": ["Not suitable for production logging", "No log levels", "Requires env var setup"]
            },
            {
              "label": "Minimal (errors only in production)",
              "value": "minimal",
              "description": "Only log errors and critical events. No debug/info/warn in production. Development uses console.log freely.",
              "pros": ["Minimal noise", "Low overhead", "Simple"],
              "cons": ["Hard to debug production issues", "No audit trail", "Missing context when things go wrong"]
            }
          ],
          "followUps": [
            "Should each subsystem have its own logger instance with a namespace prefix?"
          ]
        },
        {
          "id": "IP-Q7",
          "question": "What level of debug tracing should be built into subsystems?",
          "header": "Debug traces",
          "type": "single",
          "required": true,
          "topics": ["debugging"],
          "default": "boundary-tracing",
          "options": [
            {
              "label": "Boundary tracing (Recommended)",
              "value": "boundary-tracing",
              "description": "Trace at subsystem boundaries: entry/exit of public API methods, external service calls, and error paths. Includes timing and correlation IDs.",
              "pros": ["Low overhead", "Covers most debugging needs", "Clear request flow", "Not noisy"],
              "cons": ["Internal logic is opaque", "May miss intermediate state issues"]
            },
            {
              "label": "Comprehensive tracing (OpenTelemetry-style)",
              "value": "comprehensive",
              "description": "Full span-based tracing with OpenTelemetry. Every significant operation creates a span with attributes.",
              "pros": ["Complete visibility", "Distributed tracing ready", "Industry standard", "Amazing for debugging"],
              "cons": ["Significant overhead", "Complex setup", "Large dependency", "Can be noisy"]
            },
            {
              "label": "Error-path only",
              "value": "error-only",
              "description": "Only trace when errors occur. Capture stack traces, context, and breadcrumbs leading to the error.",
              "pros": ["Near-zero overhead in happy path", "Focused on what matters", "Small log volume"],
              "cons": ["Blind to slow operations", "No visibility into normal flow", "Hard to trace intermittent issues"]
            },
            {
              "label": "Conditional (flag-gated)",
              "value": "conditional",
              "description": "Tracing is always coded in but gated behind feature flags or environment variables. Enable per-subsystem in production.",
              "pros": ["Zero cost when off", "Enable per-subsystem", "Full control"],
              "cons": ["Feature flag infrastructure needed", "Code is more complex", "Easy to forget to add traces"]
            }
          ],
          "followUps": [
            "Should debug traces include request/response payloads (with PII redaction)?"
          ]
        }
      ]
    },
    {
      "id": 4,
      "name": "How to Build — Design Principles",
      "description": "How strictly to follow SOLID, DRY, and other design principles",
      "targetDuration": "1-2 minutes",
      "questions": [
        {
          "id": "IP-Q8",
          "question": "How strictly should SOLID principles be followed?",
          "header": "SOLID",
          "type": "single",
          "required": true,
          "topics": ["designPrinciples"],
          "default": "pragmatic-solid",
          "options": [
            {
              "label": "Pragmatic SOLID (Recommended)",
              "value": "pragmatic-solid",
              "description": "Follow SOLID where it adds value. SRP and DIP always. ISP and OCP when interfaces have 2+ implementations. LSP when using inheritance.",
              "pros": ["Right-sized abstraction", "Avoids over-engineering", "Interfaces when needed, not speculative"],
              "cons": ["Judgment calls required", "Less consistent than strict approach"]
            },
            {
              "label": "Strict SOLID",
              "value": "strict-solid",
              "description": "Every class has one responsibility. Every dependency is injected via interface. All principles enforced everywhere.",
              "pros": ["Maximum testability", "Easy to swap implementations", "Clear boundaries", "Consistent patterns"],
              "cons": ["More files and interfaces", "Over-abstraction for simple cases", "Slower initial development"]
            },
            {
              "label": "Relaxed (SOLID-aware)",
              "value": "relaxed-solid",
              "description": "Be aware of SOLID but don't enforce. Extract interfaces only when testing demands it. Inline dependencies when simple.",
              "pros": ["Fastest to write", "Less boilerplate", "Direct and readable"],
              "cons": ["Harder to test in isolation", "Tighter coupling", "Harder to refactor later"]
            }
          ],
          "followUps": [
            "Are there specific SOLID principles you care about most? (e.g., always DIP for external services)"
          ]
        },
        {
          "id": "IP-Q9",
          "question": "How aggressively should code be DRY (Don't Repeat Yourself)?",
          "header": "DRY",
          "type": "single",
          "required": true,
          "topics": ["designPrinciples"],
          "default": "rule-of-three",
          "options": [
            {
              "label": "Rule of Three (Recommended)",
              "value": "rule-of-three",
              "description": "Duplicate once is fine. On third occurrence, extract to a shared utility. Prefer duplication over premature abstraction.",
              "pros": ["Avoids premature abstraction", "Abstractions are informed by real usage", "Simple to start"],
              "cons": ["Some duplication exists temporarily", "Requires discipline to extract on third"]
            },
            {
              "label": "Strict DRY",
              "value": "strict-dry",
              "description": "No duplication ever. Extract immediately on second occurrence. Every piece of knowledge has a single source.",
              "pros": ["Single source of truth", "Changes in one place", "Consistent behavior"],
              "cons": ["Premature abstractions", "Tight coupling through shared code", "Harder to understand indirect code"]
            },
            {
              "label": "WET (Write Everything Twice)",
              "value": "wet",
              "description": "Tolerate duplication freely. Only extract when 3+ copies exist AND the abstraction is obvious. Prefer locality over DRY.",
              "pros": ["Maximum locality", "No wrong abstractions", "Easy to understand each module independently"],
              "cons": ["More code to maintain", "Inconsistencies between copies", "Bug fixes needed in multiple places"]
            }
          ],
          "followUps": [
            "Should cross-subsystem shared code live in a dedicated 'shared' or 'common' subsystem?"
          ]
        },
        {
          "id": "IP-Q10",
          "question": "What testing strategy should be followed for new subsystems?",
          "header": "Testing",
          "type": "single",
          "required": true,
          "topics": ["testing"],
          "default": "test-alongside",
          "options": [
            {
              "label": "Test alongside implementation (Recommended)",
              "value": "test-alongside",
              "description": "Write tests as you implement. Each module gets a co-located test file. Focus on public API behavior, not internals.",
              "pros": ["Tests inform design", "Catches bugs early", "Co-located tests are easy to find", "Balanced speed/quality"],
              "cons": ["Slightly slower initial development", "May need to refactor tests with code"]
            },
            {
              "label": "Test-first (strict TDD)",
              "value": "test-first",
              "description": "Write failing test → implement → refactor. Red-Green-Refactor cycle for every public function.",
              "pros": ["Tests drive design", "Near-100% coverage", "Confidence in every change", "Better API design"],
              "cons": ["Slower for exploratory work", "Overhead for simple functions", "Requires TDD discipline"]
            },
            {
              "label": "Integration tests first",
              "value": "integration-first",
              "description": "Start with integration/API tests that test the subsystem as a whole. Add unit tests only for complex internal logic.",
              "pros": ["Tests real behavior", "Fewer tests to maintain", "Refactor-resistant", "Higher confidence per test"],
              "cons": ["Slower to run", "Harder to pinpoint failures", "Setup complexity"]
            },
            {
              "label": "Minimal (critical paths only)",
              "value": "minimal-tests",
              "description": "Test only critical business logic and error paths. No tests for trivial code, configuration, or simple CRUD.",
              "pros": ["Fast development", "Tests where they matter", "Low maintenance"],
              "cons": ["Coverage gaps", "Regressions in untested code", "Less confidence in refactoring"]
            }
          ],
          "followUps": [
            "Should tests use real dependencies or mocks for external services?"
          ]
        }
      ]
    },
    {
      "id": 5,
      "name": "How to Build — Platform & Build Configuration",
      "description": "Runtime, tooling, and build pipeline preferences",
      "targetDuration": "1-2 minutes",
      "questions": [
        {
          "id": "IP-Q11",
          "question": "What is the target runtime and language?",
          "header": "Runtime",
          "type": "single",
          "required": true,
          "topics": ["platform"],
          "default": "auto-detect",
          "autoDetectField": "platform.language",
          "options": [
            {
              "label": "TypeScript (strict) (Recommended)",
              "value": "typescript-strict",
              "description": "TypeScript with strict mode enabled. noImplicitAny, strictNullChecks, noUncheckedIndexedAccess.",
              "pros": ["Maximum type safety", "Catches more bugs at compile time", "Better IDE support"],
              "cons": ["More type annotations needed", "Some library types are incomplete"]
            },
            {
              "label": "TypeScript (standard)",
              "value": "typescript-standard",
              "description": "TypeScript with default strictness. strict: true but without additional strict flags.",
              "pros": ["Good type safety", "Less friction than strict mode", "Industry standard"],
              "cons": ["Some type holes possible", "Less safe than strict"]
            },
            {
              "label": "JavaScript (with JSDoc types)",
              "value": "javascript-jsdoc",
              "description": "Plain JavaScript with JSDoc type annotations for IDE support. No compilation step.",
              "pros": ["No build step for types", "Easy to adopt", "Works with checkJs"],
              "cons": ["Less enforcement", "Verbose type syntax", "Easy to skip types"]
            },
            {
              "label": "JavaScript (untyped)",
              "value": "javascript",
              "description": "Plain JavaScript without type annotations. Fastest to write, least safe.",
              "pros": ["Maximum speed", "No tooling needed", "Simple"],
              "cons": ["No type safety", "Runtime errors", "Harder to maintain at scale"]
            }
          ]
        },
        {
          "id": "IP-Q12",
          "question": "What package manager and build tool should be used?",
          "header": "Build tools",
          "type": "single",
          "required": true,
          "topics": ["platform"],
          "default": "auto-detect",
          "autoDetectField": "platform.packageManager",
          "options": [
            {
              "label": "pnpm (Recommended for monorepos)",
              "value": "pnpm",
              "description": "Fast, disk-efficient package manager with first-class workspace support.",
              "pros": ["Fastest installs", "Strict dependency resolution", "Excellent monorepo support", "Disk efficient"],
              "cons": ["Less widespread than npm", "Some tools assume npm"]
            },
            {
              "label": "npm",
              "value": "npm",
              "description": "Default Node.js package manager. Universal compatibility.",
              "pros": ["Universal", "Zero setup", "Every tutorial uses it"],
              "cons": ["Slower installs", "Flat node_modules", "Phantom dependencies"]
            },
            {
              "label": "yarn (v4/berry)",
              "value": "yarn",
              "description": "Yarn with Plug'n'Play. Zero-install, strict dependency resolution.",
              "pros": ["Zero-install possible", "Strict deps", "Fast"],
              "cons": ["PnP compatibility issues", "Different mental model", "Some tools need patches"]
            },
            {
              "label": "bun",
              "value": "bun",
              "description": "All-in-one runtime, bundler, and package manager. Extremely fast.",
              "pros": ["Fastest everything", "Built-in bundler/test runner", "Drop-in Node replacement"],
              "cons": ["Newer, less stable", "Some Node APIs missing", "Smaller ecosystem"]
            }
          ]
        },
        {
          "id": "IP-Q13",
          "question": "What test framework should be used?",
          "header": "Test framework",
          "type": "single",
          "required": true,
          "topics": ["platform", "testing"],
          "default": "auto-detect",
          "autoDetectField": "platform.testFramework",
          "options": [
            {
              "label": "Vitest (Recommended)",
              "value": "vitest",
              "description": "Vite-native test framework. Fast, ESM-first, Jest-compatible API.",
              "pros": ["Very fast", "ESM native", "Jest-compatible API", "Built-in coverage", "TypeScript out of box"],
              "cons": ["Newer than Jest", "Slightly different config"]
            },
            {
              "label": "Jest",
              "value": "jest",
              "description": "Most popular test framework. Mature, extensive ecosystem.",
              "pros": ["Massive ecosystem", "Well-documented", "Snapshot testing", "Built-in mocking"],
              "cons": ["Slower than Vitest", "ESM support still experimental", "Heavy config for TS"]
            },
            {
              "label": "Node test runner (node:test)",
              "value": "node-test",
              "description": "Built-in Node.js test runner. Zero dependencies.",
              "pros": ["Zero dependencies", "Built into Node", "Fast", "Simple"],
              "cons": ["Less mature", "Fewer assertion helpers", "Limited ecosystem"]
            },
            {
              "label": "Match existing project",
              "value": "match-existing",
              "description": "Use whatever test framework the project already uses. Auto-detect from package.json.",
              "pros": ["Consistency", "No new tooling to learn", "Uses existing config"],
              "cons": ["May not be the best choice for new code"]
            }
          ]
        },
        {
          "id": "IP-Q14",
          "question": "Any additional configuration the implementation agents should know about?",
          "header": "Extra config",
          "type": "open",
          "required": false,
          "topics": ["platform"],
          "default": "",
          "options": [
            {
              "label": "ESM modules (import/export)",
              "description": "Use ES modules everywhere, no CommonJS require()"
            },
            {
              "label": "Specific Node version",
              "description": "Target a specific Node.js version (e.g., Node 20 LTS)"
            },
            {
              "label": "Docker containerized",
              "description": "Subsystems should include Dockerfile and health checks"
            },
            {
              "label": "No additional config",
              "description": "The defaults are fine"
            }
          ],
          "followUps": []
        }
      ]
    }
  ],
  "enforcement": {
    "description": "ACIS enforces ALL 'how' preferences using a Three-Tier Verification Engine. This is systemic — not user-configurable. Checks escalate from comment-stripped pattern matching (T1) through AST structural analysis (T2) to schema-constrained agent review (T3). Violations BLOCK the step until fixed.",
    "engine": "configs/enforcement-engine.json",
    "engineSchema": "schemas/enforcement-engine.schema.json",
    "scriptLibrary": "templates/ast-verification-scripts.md",
    "mechanism": "After each step commit, ACIS runs tiered verification checks against changed files. T1 (comment-stripped grep) filters candidates fast. T2 (AST/compiler) confirms violations structurally. T3 (schema-constrained agent review) handles semantic checks. Any failure BLOCKS the commit.",
    "maxRetries": 3,
    "onMaxRetriesExceeded": "Step marked 'blocked' with violation details. User notified. Agent moves to next step.",
    "verificationTiers": {
      "T1": {
        "name": "Comment-Stripped Pattern Matching",
        "speed": "fast (~1s per file)",
        "accuracy": "~90%",
        "when": "Naming, logging, simple patterns. Always runs first as fast filter.",
        "howItWorks": "Strips // and /* */ comments via node -e before grep/find. Eliminates false positives from commented-out code.",
        "falsePositiveReduction": "Comments stripped before matching. Still may match string literals containing patterns (rare)."
      },
      "T2": {
        "name": "AST Structural Analysis",
        "speed": "medium (~200ms per file)",
        "accuracy": "~99%",
        "when": "Imports, exports, error handling, type safety, layer dependencies, circular deps.",
        "howItWorks": "Uses TypeScript Compiler API (node -e with require('typescript')) or npx ts-morph/madge. Parses code into AST and checks structural properties.",
        "falsePositiveReduction": "Only examines actual code nodes (import declarations, throw statements, type annotations). Cannot be fooled by comments, strings, or dead code.",
        "prerequisites": ["node", "typescript in node_modules or npx"]
      },
      "T3": {
        "name": "Schema-Constrained Agent Review",
        "speed": "slow (~5-15s batched)",
        "accuracy": "semantic understanding",
        "when": "SOLID adherence, DRY strategy, code organization patterns, debug instrumentation.",
        "howItWorks": "Claude agent reviews code with mandatory JSON output schema. Agent MUST produce { verdict: PASS|FAIL, violations: [{file, line, rule, description, severity, suggested_fix}], confidence: 0.0-1.0, evidence: [...] }. Invalid output triggers T2 fallback.",
        "falsePositiveReduction": "Semantic understanding of code intent. Can distinguish intentional duplication from accidental. Mandatory evidence citations prevent hallucinated violations.",
        "determinism": "Confidence score + mandatory evidence + schema validation. Confidence < 0.7 triggers automatic T2 cross-verification."
      }
    },
    "twoStageDetection": {
      "description": "Performance optimization: T1 acts as fast filter, T2/T3 verify only candidates.",
      "pattern": "Stage 1: T1 on all changed files → candidate list. Stage 2: T2/T3 on candidates only.",
      "skipT1IfFewFiles": 5,
      "benefit": "Minimizes expensive AST parsing while maintaining accuracy. 100 files at T2 = ~20s. With two-stage: T1 filters to ~10 candidates = ~2s T2."
    },
    "preferenceChecks": {
      "codingStyle.fileNaming": {
        "description": "Verify all new/modified files match the chosen naming convention",
        "recommendedTier": "T1",
        "rationale": "File naming is a file-system property, not a code property. grep/find is reliable here — no comments to confuse.",
        "checks": {
          "kebab-case": "find ${worktree}/src/${subsystem} -maxdepth 5 -name '*.ts' -o -name '*.tsx' | grep -v node_modules | grep -v '.test.' | grep -v '.spec.' | while read f; do b=$(basename \"$f\"); echo \"$b\" | grep -q '[A-Z]' && echo \"$f: uppercase in filename\"; done",
          "camelCase": "find ${worktree}/src/${subsystem} -maxdepth 5 -name '*.ts' -o -name '*.tsx' | grep -v node_modules | while read f; do b=$(basename \"$f\"); echo \"$b\" | grep -q '-' && echo \"$f: kebab-case in filename\"; done",
          "PascalCase": "find ${worktree}/src/${subsystem} -maxdepth 5 -name '*.ts' -o -name '*.tsx' | grep -v node_modules | while read f; do b=$(basename \"$f\"); echo \"$b\" | grep -qE '[-_]' && echo \"$f: separator in filename\"; done",
          "snake_case": "find ${worktree}/src/${subsystem} -maxdepth 5 -name '*.ts' -o -name '*.tsx' | grep -v node_modules | while read f; do b=$(basename \"$f\"); echo \"$b\" | grep -qE '[A-Z-]' && echo \"$f: uppercase or kebab in filename\"; done"
        },
        "passCondition": "Command outputs zero lines (no naming violations)",
        "fixInstruction": "Rename files to match the chosen naming convention and update all imports"
      },
      "codingStyle.importStyle": {
        "description": "Verify imports use the chosen style consistently",
        "recommendedTier": "T2",
        "rationale": "Grep catches imports in comments and strings. AST analysis checks only actual import declarations.",
        "T1_command": "Comment-stripped grep: strips comments then searches for import pattern violations",
        "T2_command": "AST: Uses TypeScript parser to examine only ImportDeclaration nodes. See ast-verification-scripts.md#import-style-check",
        "checks": {
          "path-aliases": { "violation_regex": "^\\.\\.", "meaning": "Relative imports should be @/ path aliases" },
          "relative": { "violation_regex": "^@/", "meaning": "Path alias imports should be relative" },
          "package-imports": { "violation_regex": "^\\.\\.", "meaning": "Relative imports should be package imports" }
        },
        "passCondition": "Zero import violations in actual import declarations (AST-verified)",
        "fixInstruction": "Convert all imports to the chosen import style"
      },
      "codingStyle.exportStyle": {
        "description": "Verify exports match chosen pattern",
        "recommendedTier": "T2",
        "rationale": "Grep for 'export default' catches commented examples. AST finds only real export assignments.",
        "T2_command": "AST: Checks ExportAssignment and DefaultKeyword modifier nodes. See ast-verification-scripts.md#export-style-check",
        "checks": {
          "named-exports": "T2: Find ExportAssignment nodes (default exports) — must be zero",
          "mixed-exports": "Always PASS",
          "barrel-exports": "T1: Check index.ts/index.js file exists"
        },
        "passCondition": "Export style matches chosen pattern (AST-verified)",
        "fixInstruction": "Convert exports to the chosen export pattern"
      },
      "errorHandling.strategy": {
        "description": "Verify error handling follows chosen strategy",
        "recommendedTier": "T2",
        "rationale": "Critical distinction: 'throw new Error()' vs 'throw new AuthError()'. Grep cannot reliably tell them apart when code has multi-line throw expressions. AST distinguishes the constructor name in NewExpression nodes.",
        "T1_command": "Comment-stripped grep for 'throw new Error(' — eliminates commented examples",
        "T2_command": "AST: Finds ThrowStatement → NewExpression → checks constructor Identifier.text === 'Error'. Custom error classes (AuthError, ValidationError) pass. See ast-verification-scripts.md#error-handling-check",
        "checks": {
          "typed-errors": "T2: ThrowStatement with NewExpression('Error') → VIOLATION. NewExpression('AuthError') → PASS",
          "result-type": "T2: Any ThrowStatement in non-test code → VIOLATION",
          "error-codes": "T2: ThrowStatement with NewExpression('Error') without code property → VIOLATION",
          "mixed": "Always PASS"
        },
        "passCondition": "Zero violations for the chosen strategy (AST-verified, not line-matched)",
        "fixInstruction": "Replace raw Error throws with the chosen error handling pattern"
      },
      "logging.approach": {
        "description": "Verify no raw console.* in production code when structured logger is chosen",
        "recommendedTier": "T1",
        "rationale": "Console.log is a simple pattern. T1 comment-stripping eliminates the main false positive source (commented-out console.log). T2 available for escalation.",
        "T1_command": "Comment-stripped: strips comments then searches for console.log/warn/error/info/debug",
        "T2_command": "AST: Finds CallExpression where callee is PropertyAccessExpression with object 'console'. See ast-verification-scripts.md#console-usage-check",
        "checks": {
          "structured-logger": "T1→T2: No console.log|warn|error|info|debug in non-comment, non-test code",
          "console-levels": "Always PASS (console with levels is the chosen approach)",
          "debug-namespaced": "T1: No console.log in non-comment, non-test code (console.warn/error OK)",
          "minimal": "T1: No console.log|info|debug in non-comment, non-test code (console.error OK)"
        },
        "passCondition": "Zero console.* calls in production code (comment-stripped or AST-verified)",
        "fixInstruction": "Replace console.* calls with the chosen logging approach"
      },
      "debugging.traceLevel": {
        "description": "Verify debug instrumentation matches chosen level",
        "recommendedTier": "T3",
        "rationale": "Trace instrumentation requires semantic understanding: 'does this exported function have entry/exit traces?' Cannot be verified by pattern matching alone.",
        "T3_criteria": "Agent reviews each exported function for trace instrumentation at the chosen level. Must produce structured verdict with file:line evidence for each missing trace.",
        "checks": {
          "boundary-tracing": "T3: Every exported function has entry/exit trace calls",
          "comprehensive": "T3: Every function with side effects creates an OpenTelemetry span",
          "error-only": "T3: Every catch block captures context and breadcrumbs",
          "conditional": "T3: Trace calls gated behind env var or feature flag"
        },
        "passCondition": "Agent verdict is PASS with confidence >= 0.7",
        "fixInstruction": "Add trace instrumentation at the required level"
      },
      "designPrinciples.solidAdherence": {
        "description": "Verify SOLID principle adherence at the chosen strictness level",
        "recommendedTier": "T2+T3",
        "rationale": "Two-tier: T2 catches structural violations (large classes = SRP, constructor DI = DIP). T3 handles semantic violations (is this class doing 2 unrelated things?).",
        "T2_command": "AST: Checks class size (method count, line count), constructor NewExpression for Service/Repository, interface member count. See ast-verification-scripts.md#solid-structural-check",
        "T3_criteria": "Agent reviews for semantic SOLID compliance. Must cite specific file:line evidence. Mandatory structured JSON output.",
        "checks": {
          "pragmatic-solid": "T2: class methods <= 10, no constructor DI violations. T3: single clear responsibility per file",
          "strict-solid": "T2: class methods <= 7, no constructor DI, interfaces <= 5 members. T3: all SOLID principles enforced",
          "relaxed-solid": "Always PASS"
        },
        "passCondition": "T2 structural checks pass AND T3 agent verdict is PASS with confidence >= 0.7",
        "fixInstruction": "Refactor code to meet SOLID adherence requirements at the chosen level"
      },
      "designPrinciples.dryStrategy": {
        "description": "Verify DRY adherence at chosen threshold",
        "recommendedTier": "T3",
        "rationale": "Code duplication requires understanding logical equivalence, not just text matching. Two functions may look different but do the same thing. Only semantic review can catch this reliably.",
        "T3_criteria": "Agent reviews for code duplication at the chosen threshold. Must identify specific duplicated blocks with file:line citations for both copies.",
        "checks": {
          "rule-of-three": "T3: Flag code blocks of 5+ lines that appear 3+ times",
          "strict-dry": "T3: Flag any code blocks of 3+ lines that appear 2+ times",
          "wet": "Always PASS"
        },
        "passCondition": "Agent verdict is PASS with confidence >= 0.7",
        "fixInstruction": "Extract duplicated code into shared utilities"
      },
      "testing.strategy": {
        "description": "Verify test files exist per the chosen testing strategy",
        "recommendedTier": "T1",
        "rationale": "Test file existence is a file-system check. No AST needed.",
        "checks": {
          "test-alongside": "T1: For each .ts/.tsx impl file, verify co-located .test.ts or .spec.ts exists",
          "test-first": "T1: Same as test-alongside (commit order not mechanically verifiable)",
          "integration-first": "T1: At least one integration test file in subsystem test directory",
          "minimal-tests": "T1: Test files exist for files containing exported functions"
        },
        "passCondition": "Required test files exist per the chosen testing strategy",
        "fixInstruction": "Create missing test files per the chosen testing strategy"
      },
      "platform.language": {
        "description": "Verify TypeScript strictness and type safety",
        "recommendedTier": "T2",
        "rationale": "The 'any' type keyword appears in comments, string literals, and variable names like 'anyValue'. Only AST analysis reliably finds type-position 'any' keywords.",
        "T1_command": "Comment-stripped grep for ': any' and 'as any' — eliminates commented-out type annotations",
        "T2_command": "AST: Finds AnyKeyword nodes in the AST. Zero false positives — only matches 'any' in actual type positions. See ast-verification-scripts.md#any-type-check",
        "checks": {
          "typescript-strict": "T2: AnyKeyword count = 0 in AST (type annotations, assertions, generics)",
          "typescript-standard": "T1: Verify .ts/.tsx extensions",
          "javascript-jsdoc": "T1: Verify .js/.jsx extensions + JSDoc @param/@returns presence",
          "javascript": "T1: Verify .js/.jsx extensions"
        },
        "passCondition": "Zero 'any' usage when typescript-strict chosen (AST-verified)",
        "fixInstruction": "Replace 'any' with proper types"
      },
      "architecture.layerDeps": {
        "description": "Verify lower architectural layers never import from higher layers",
        "recommendedTier": "T2",
        "rationale": "Layer violation detection via grep matches import paths in comments and strings. AST analysis checks only actual ImportDeclaration nodes and resolves the layer from directory structure.",
        "T2_command": "AST: For each ImportDeclaration, determine file's layer and import's layer from directory path. Flag if file layer < import layer. See ast-verification-scripts.md#layer-dependency-check",
        "passCondition": "Zero layer dependency violations (AST-verified)",
        "fixInstruction": "Move the dependency to a lower layer or invert using an interface"
      },
      "architecture.circularDeps": {
        "description": "Detect circular dependencies between modules",
        "recommendedTier": "T2",
        "rationale": "Circular dependencies require full dependency graph analysis. Cannot be detected by grep.",
        "T2_command": "npx madge --circular --json. See ast-verification-scripts.md#circular-dependency-check",
        "passCondition": "Zero circular dependency chains",
        "fixInstruction": "Break circular dependency by extracting shared interface or using dependency injection"
      }
    },
    "enforcementLoop": [
      "1. Agent completes implementation step and stages changed files",
      "2. ACIS determines which preference checks apply to staged files",
      "3. TIER SELECTION per check:",
      "   a. Look up check's recommendedTier in enforcement engine config",
      "   b. Verify tier prerequisites are met (node, typescript, npx)",
      "   c. If prerequisites not met, fall back to lower tier",
      "4. TWO-STAGE DETECTION (if enabled and > 5 files):",
      "   a. Run T1 (comment-stripped grep) on ALL changed files → candidate list",
      "   b. Run T2/T3 ONLY on candidates from T1",
      "5. EXECUTE CHECKS at selected tier:",
      "   a. T1: Comment-stripped pattern matching (node -e + grep)",
      "   b. T2: AST analysis (node -e with TypeScript API / npx ts-morph / npx madge)",
      "   c. T3: Schema-constrained agent review (mandatory JSON output: verdict + violations + confidence + evidence)",
      "6. T3 VALIDATION: If agent review output fails schema validation or confidence < 0.7, fall back to T2",
      "7. IF any check FAILS:",
      "   a. Step is BLOCKED — commit is rejected",
      "   b. Agent receives structured violation report: { check, preference, tier, violation, file, line, fixInstruction }",
      "   c. Agent fixes ALL violations in the same worktree",
      "   d. Agent re-stages and re-attempts commit",
      "   e. ACIS re-runs ONLY failed checks (loop back to step 5, up to maxRetries)",
      "8. IF all checks PASS → commit accepted, step marked 'complete'",
      "9. After maxRetries (3) failures → step marked 'blocked', violation details saved, user notified"
    ],
    "violationFormat": {
      "check": "errorHandling.strategy",
      "preference": "typed-errors",
      "tier": "T2",
      "violation": "throw new Error('auth failed') — use typed error class (e.g., throw new AuthError('auth failed'))",
      "file": "src/auth/auth-service.ts",
      "line": 42,
      "fixInstruction": "Replace 'throw new Error()' with 'throw new AuthError()' — import from errors/auth-error.ts",
      "severity": "BLOCK",
      "attempt": 1,
      "evidence": "AST: ThrowStatement at line 42, NewExpression with Identifier.text = 'Error'"
    },
    "complianceReport": {
      "description": "Always generated at batch completion — systemic, not optional",
      "sections": [
        "Per-subsystem compliance summary",
        "Total checks run / passed / failed-then-fixed / blocked",
        "Tier usage breakdown (T1/T2/T3 check counts and accuracy)",
        "Violations that required agent retry (with tier and evidence details)",
        "Final compliance score per preference category (0-100%)",
        "Steps that were blocked and could not be auto-fixed",
        "False positive rate per tier (if any T1 results overridden by T2)"
      ]
    }
  },
  "outputSchema": {
    "description": "The collected preferences are stored as implementation_preferences in the batch state and passed to each implementation agent. Split into 'what' (scope decisions) and 'how' (coding decisions). Enforcement is automatic — every 'how' preference becomes a verifiable check.",
    "shape": {
      "scope": {
        "mvpSelection": "all-subsystems | core-only | manual-select",
        "selectedSubsystems": ["SPEC-auth-service", "SPEC-sync-engine"],
        "deferredSubsystems": ["SPEC-analytics"],
        "priorityStrategy": "dependency-order | value-first | risk-first | inside-out",
        "stubStrategy": "interface-stubs | mock-implementations | no-stubs",
        "featureFlags": "environment-flags | config-flags | no-flags | flag-service",
        "deliverables": ["code-tests-types", "include-api-docs"],
        "milestoneConstraints": "string (from follow-up)"
      },
      "codingStyle": {
        "fileNaming": "kebab-case | camelCase | PascalCase | snake_case",
        "codeOrganization": "feature-based | layer-based | hybrid",
        "importStyle": "path-aliases | relative | package-imports",
        "exportStyle": "named-exports | mixed-exports | barrel-exports",
        "componentNaming": "PascalCase (if specified in follow-up)"
      },
      "errorHandling": {
        "strategy": "typed-errors | result-type | error-codes | mixed",
        "globalErrorHandler": "boolean (from follow-up)"
      },
      "logging": {
        "approach": "structured-logger | console-levels | debug-namespaced | minimal",
        "subsystemNamespaces": "boolean (from follow-up)"
      },
      "debugging": {
        "traceLevel": "boundary-tracing | comprehensive | error-only | conditional",
        "includePayloads": "boolean (from follow-up)",
        "piiRedaction": "boolean (from follow-up)"
      },
      "designPrinciples": {
        "solidAdherence": "pragmatic-solid | strict-solid | relaxed-solid",
        "solidEmphasis": "string (from follow-up, e.g., 'DIP for external services')",
        "dryStrategy": "rule-of-three | strict-dry | wet",
        "sharedCodeLocation": "string (from follow-up)"
      },
      "testing": {
        "strategy": "test-alongside | test-first | integration-first | minimal-tests",
        "mockStrategy": "string (from follow-up)",
        "framework": "vitest | jest | node-test | match-existing"
      },
      "platform": {
        "language": "typescript-strict | typescript-standard | javascript-jsdoc | javascript",
        "packageManager": "pnpm | npm | yarn | bun",
        "additionalConfig": "string (from open question)"
      }
    }
  }
}
